# this file defines the CI/CD stages for the TIDO viewer.
# in some cases they invoke scripts provided at .ci-scripts/ in order to
# keep this file slim and clear. please have a look at these scripts for
# information that goes beyond the documentation of the single stages.

cache:
  paths:
  - node_modules/

stages:
  - clean
  - build
  - deploy
  - preserve-pages

# Templates
.git: &git
  - eval $(ssh-agent -s)
  - echo "$DEPLOY_KEY" | tr -d '\r' | ssh-add - > /dev/null
  - mkdir -p ~/.ssh
  - chmod 700 ~/.ssh
  - ssh-keyscan gitlab.gwdg.de  >> ~/.ssh/known_hosts
  - git config --global user.email "tido@gitlab.gwdg.de"
  - git config --global user.name "Gitlab CI"

# this stage checks if an entry point is set in src/index.template.html and removes it.
# the reasoning behind this is that the entry point should be empty on `develop` and `main`
# so that releases don't accidentally ship an entry point.
# during this stage, the variable $CONTINUE_BUILD is set and exported which determines if
# the following pipeline stages are fully executed. if an entry point has to be removed, it is
# set to 'false' since src/index.template.html is modified and recomitted which triggers a new
# pipeline.
clean_up:
  image: docker.gitlab.gwdg.de/mrodzis/docker-images/debian
  stage: clean
  only:
    - main
    - develop
  script:
    - *git
    - bash .ci-scripts/remove_entrypoint.sh
  artifacts:
    reports:
      dotenv: build.env

# builds TIDO on feature and bugfix branches.
build_test:
  image: docker.gitlab.gwdg.de/subugoe/emo/qviewer/node:latest
  except:
   - main
   - develop
  stage: build
  script:
   - bash .ci-scripts/build.sh
  artifacts:
    paths:
     - dist/

# builds TIDO on `main` and `develop`.
# the software is only built if no entry point has been removed during
# the 'clean' stage.
build_main_and_develop:
  image: docker.gitlab.gwdg.de/subugoe/emo/qviewer/node:latest
  only:
   - main
   - develop
  stage: build
  script:
   - if [[ $CONTINUE_BUILD == "true" ]]; then echo "Continue build"; bash .ci-scripts/build.sh; else echo "Stop build"; fi
  artifacts:
    paths:
     - dist/
    expire_in: 1 mos

# this job triggers a new build of the Ahiqar specific TIDO viewer after a
# merge to `main` (which is only done during a release).
# this way the Ahiqar specific TIDO gets updated automatically if a new
# version of the generic TIDO is available.
# this connection will be removed at some point of the TIDO development.
update-ahikar:
  stage: deploy
  only:
    - main
  variables:
    UPDATE: "true"
    UPSTREAM_COMMIT_SHA: "${CI_COMMIT_SHA}"
  trigger: "subugoe/ahiqar/ahiqar-tido"

# creates the GitLab pages for the environments.
# if an entry point has been removed during the 'clean' stage, we temporarily set a custom
# 404 page on `main` and `develop` which will replaced during the next pipeline. since
# removing the entry point triggers a new pipeline, the 404 state will only last for a few minutes.
pages:
  image: docker.gitlab.gwdg.de/mrodzis/docker-images/debian
# at the very early stage lets deploy for every branch
#  only:
#    - main
#    - develop
  stage: deploy
  cache:
    untracked: true
    paths:
      - public
  when: always
  script:
    - if [[ $CONTINUE_BUILD == "false" && ! -d dist ]]; then echo "Build not continued. Create 404 page."; bash .ci-scripts/set-404-page.sh; else echo "Proceed page build as usual."; fi
    - bash .ci-scripts/update-artifacts.sh
    - bash .ci-scripts/gitlab-remove-old-artifacts.sh
  environment:
    name: ${CI_COMMIT_REF_SLUG}
    url: https://subugoe.pages.gwdg.de/emo/Qviewer/${CI_COMMIT_REF_SLUG}/
  artifacts:
    name: "$CI_COMMIT_SHORT_SHA"
    paths:
     - public

# this stage serves for preserving the pages that have been created in the last two weeks.
# without tihs job the pages would get lost or be overwritten by the 'pages' job.
pushback:
  before_script:
    - dnf install -y zip
  image: docker.gitlab.gwdg.de/mgoebel/swiss_knife/fedora:latest
  stage: preserve-pages
  script:
    -  zip -r updated-artifact.zip public
  artifacts:
    name: "updated-artifact"
    paths:
      - updated-artifact.zip

# when a git flow release is made, a tag will be pushed starting this job. it
# will keep the resulting artifact from the job declared in `JOB_NUMBER_TO_PRESERVE`
# and it will set up a Gitlab release at the repo. therefore the merge message starting
# at the release branch should be written in markdown, using a backslash as escape character
# `\` before `#`.
.release:
  image: docker.gitlab.gwdg.de/fontane-notizbuecher/build:latest
  stage: deploy
  only:
    - tags
  variables:
    JOB_NUMBER_TO_PRESERVE: 1
  script:
    # it is also possible to query for a job name by altering the jq filter
    - 'curl --output jobs.json --header "PRIVATE-TOKEN: $GITLAB_TOKEN" "$CI_API_V4_URL/projects/$CI_PROJECT_ID/pipelines/$CI_PIPELINE_ID/jobs"'
    - CI_JOB_TARGET=$(jq ".[$((JOB_NUMBER_TO_PRESERVE - 1))].id" < jobs.json)
    - echo $CI_JOB_TARGET
    # keep artifact (release will link there)
    - 'curl --request POST --header "PRIVATE-TOKEN: $GITLAB_TOKEN" "$CI_API_V4_URL/projects/$CI_PROJECT_ID/jobs/$CI_JOB_TARGET/artifacts/keep"'
    # create release data
    # parse commit message (markdown, lines starting with “\”)
    - MARKDOWN=$(echo "$CI_COMMIT_MESSAGE" | sed 's=^\\==g')
    # prepare the json file
    - 'jq
      ".name = \"$CI_PROJECT_PATH $CI_COMMIT_TAG\" |
      .tag_name = \"$CI_COMMIT_TAG\" |
      .description = \"$MARKDOWN\" |
      .assets.links[0].name = \"package\" |
      .assets.links[0].url = \"https://gitlab.gwdg.de/$CI_PROJECT_PATH/-/jobs/$CI_JOB_TARGET/artifacts/download\"
      " < .gitlab/gitlab-release.json.tmpl > gitlab-release.json'
    - 'curl --header "Content-Type: application/json" --header "PRIVATE-TOKEN: $GITLAB_TOKEN" --data @gitlab-release.json --request POST $CI_API_V4_URL/projects/$CI_PROJECT_ID/releases'
  artifacts:
    paths:
      - gitlab-release.json
